<!-- https://threejs-journey.com/lessons/environment-map -->
<!-- Generate env maps with AI: https://skybox.blockadelabs.com/ -->

<script setup lang="ts">
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
import { onBeforeUnmount, onMounted, ref } from "vue";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader";
import { RGBELoader } from "three/examples/jsm/loaders/RGBELoader";
import { GroundProjectedSkybox } from "three/addons/objects/GroundProjectedSkybox";
import * as dat from "dat.gui"; // OR INSTALL 'lil-gui'

const canvas = ref<HTMLCanvasElement | null>(null);

let renderer: THREE.WebGLRenderer | null = null;
const gltfLoader = new GLTFLoader();
const cubeTextureLoader = new THREE.CubeTextureLoader();
const rgbeLoader = new RGBELoader();
const textureLoader = new THREE.TextureLoader();
const gui = new dat.GUI({ width: 400 });

// Scene
const scene = new THREE.Scene();

const state = {
  envMapIntensity: 1,
};
gui.add(state, "envMapIntensity", 0, 10, 0.01).onFinishChange(updateAllMaterials);

// KED CHCEME UDPATNUT ENVMAP INTENSITY PRE MESHE V SCENE
function updateAllMaterials() {
  scene.traverse((child) => {
    if (child.isMesh && child.material.isMeshStandardMaterial) {
      // child.material.envMap = environmentMap;
      child.material.envMapIntensity = state.envMapIntensity;
      // child.material.needsUpdate = true;
    }
  });
}

// #### 1 #### TOTO je sposob cubemaps, kde potrebujem 6 textur
/**
const environmentMap = cubeTextureLoader.load([
  "/src/assets/environmentMaps/0/px.png",
  "/src/assets/environmentMaps/0/nx.png",
  "/src/assets/environmentMaps/0/py.png",
  "/src/assets/environmentMaps/0/ny.png",
  "/src/assets/environmentMaps/0/pz.png",
  "/src/assets/environmentMaps/0/nz.png",
]);

// APLIKUJEME NA Meshe, cize budu osvetlene podla environmentMap
scene.environment = environmentMap;
// APLIKUJEME NA BACKGROUND
scene.background = environmentMap;
scene.backgroundBlurriness = 0.2;
// meni intensitu len na bg, nie na meshe
scene.backgroundIntensity = 1;

gui.add(scene, "backgroundBlurriness", 0, 1, 0.01);
gui.add(scene, "backgroundIntensity", 0, 10, 0.01);
 */

// #### 2 #### HDR sposob (RGBE) equirectangular, better result, better lightning BUT much heavier to load and render, da sa obrabrat s lower resolution a blurom
// da sa pouzivat ze len na lightning s naozaj malym rozlisenim
// rgbeLoader.load("/src/assets/environmentMaps/0/2k.hdr", (envMap) => {
//   envMap.mapping = THREE.EquirectangularRefractionMapping;
//   scene.background = envMap;
//   scene.environment = envMap;
// });

// #### 3 #### LDR Equirectangular sposob (JPG generated by AI)
// textureLoader.load(
//   "/src/assets/environmentMaps/blockadesLabsSkybox/interior_views_cozy_wood_cabin_with_cauldron_and_p.jpg",
//   (texture) => {
//     texture.mapping = THREE.EquirectangularRefractionMapping;
//     texture.colorSpace = THREE.SRGBColorSpace; //fix colors
//     scene.environment = texture;
//     scene.background = texture;
//   }
// );

// #### 4 #### Ground projected skybox
// rgbeLoader.load("/src/assets/environmentMaps/2/2k.hdr", (envMap) => {
//   envMap.mapping = THREE.EquirectangularRefractionMapping;
//   //len svetla
//   scene.environment = envMap;

//   const skybox = new GroundProjectedSkybox(envMap);
//   gui.add(skybox, "radius", 1, 200, 0.1).name("skyboxRadius");
//   gui.add(skybox, "height", 1, 200, 0.1).name("skyboxHeight");

//   skybox.scale.setScalar(50);
//   scene.add(skybox);
// });

// #### 5 #### Realtime environment map
const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256, { type: THREE.HalfFloatType });
const cubeCamera = new THREE.CubeCamera(0.1, 100, cubeRenderTarget);
cubeCamera.layers.set(1); // aby camera nerenderovala v odraze napriklad torusKnotu samotny torusKnot, camera bude vidiet len biely torus (a pozadie)

textureLoader.load(
  "/src/assets/environmentMaps/blockadesLabsSkybox/interior_views_cozy_wood_cabin_with_cauldron_and_p.jpg",
  (texture) => {
    texture.mapping = THREE.EquirectangularRefractionMapping;
    texture.colorSpace = THREE.SRGBColorSpace; //fix colors
    // scene.environment = texture;
    scene.background = texture;
    scene.environment = cubeRenderTarget.texture;
  }
);

const holyDonut = new THREE.Mesh(
  new THREE.TorusGeometry(8, 0.5),
  new THREE.MeshBasicMaterial({ color: new THREE.Color(4, 4, 4) })
);
holyDonut.position.y = 3.5;
holyDonut.layers.enable(1);
scene.add(holyDonut);

gltfLoader.load("/src/assets/models/FlightHelmet/glTF/FlightHelmet.gltf", (gltf) => {
  gltf.scene.scale.setScalar(10);
  scene.add(gltf.scene);
  updateAllMaterials();
});

const torus = new THREE.Mesh(
  new THREE.TorusKnotGeometry(1, 0.4, 100, 16),
  new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.3, metalness: 1 })
);
torus.position.set(-4, 4, 0);

scene.add(torus);

// Sizes
const sizes = {
  width: window.innerWidth,
  height: window.innerHeight,
};

// Camera, fow and resolution (Aspect ratio)
const aspectRatio = sizes.width / sizes.height;
const camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 100);
camera.position.set(4, 5, 4);

scene.add(camera);

const handleResize = () => {
  if (!camera || !renderer) return;
  sizes.width = window.innerWidth;
  sizes.height = window.innerHeight;

  camera.aspect = sizes.width / sizes.height;
  camera.updateProjectionMatrix();
  renderer.setSize(sizes.width, sizes.height);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
};

const listenForResize = () => {
  window.addEventListener("resize", handleResize);
};

// Renderer
const setRenderer = () => {
  if (!canvas.value) return;
  listenForResize();
  const controls = new OrbitControls(camera, canvas.value);
  controls.enableDamping = true;
  // controls.target.y = 1;
  // controls.update();

  renderer = new THREE.WebGLRenderer({ canvas: canvas.value });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(sizes.width, sizes.height);
  renderer.render(scene, camera);

  startLoop(renderer, controls);
};

const clock = new THREE.Clock();
const startLoop = (renderer: THREE.WebGLRenderer, controls: OrbitControls) => {
  const tick = () => {
    const elapsedTime = clock.getElapsedTime();

    if (holyDonut) {
      holyDonut.rotation.x = Math.sin(elapsedTime) * 2;
      cubeCamera.update(renderer, scene);
    }

    controls.update();

    renderer.render(scene, camera);
    window.requestAnimationFrame(tick);
  };

  tick();
};

onMounted(setRenderer);
onBeforeUnmount(() => {
  window.removeEventListener("mousemove", handleResize);
  gui.destroy();
});
</script>

<template>
  <div class="wrapper">
    <canvas ref="canvas" />
  </div>
</template>

<style scoped>
.wrapper {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
</style>
